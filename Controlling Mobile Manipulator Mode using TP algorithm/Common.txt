import numpy as np # Import Numpy

def DH(d, theta, a, alpha):
    '''
        Function builds elementary Denavit-Hartenberg transformation matrices 
        and returns the transformation matrix resulting from their multiplication.

        Arguments:
        d (double): displacement along Z-axis
        theta (double): rotation around Z-axis
        a (double): displacement along X-axis
        alpha (double): rotation around X-axis

        Returns:
        (Numpy array): composition of elementary DH transformations
    '''
    # 1. Build matrices representing elementary transformations (based on input parameters).
    # T1: Translation along Z-axis by d
    Tz = np.array([[1, 0, 0, 0],
                   [0, 1, 0, 0],
                   [0, 0, 1, d],
                   [0, 0, 0, 1]])
    # R1: Rotation around Z-axis by theta
    Rz = np.array([[np.cos(theta), -np.sin(theta), 0, 0], [np.sin(theta), np.cos(theta), 0, 0], [0,0, 1, 0],[0,0, 0, 1]])
    # T2: Translation along X-axis by a
    Tx = np.array([[1, 0, 0, a],
                   [0, 1, 0, 0],
                   [0, 0, 1, 0],
                   [0, 0, 0, 1]])
    # R2: Rotation around X-axis by alpha
    Rx = np.array([[1,0, 0, 0], [0, np.cos(alpha), -np.sin(alpha), 0], [0,np.sin(alpha), np.cos(alpha), 0],[0,0, 0, 1]])
    # 2. Multiply matrices in the correct order (result in T).
    T = Tz @ Rz @ Tx @ Rx

    return T
 
def kinematics(d, theta, a, alpha,Tb):  # have the table as the input , call DH
    '''
        Functions builds a list of transformation matrices, for a kinematic chain,
        descried by a given set of Denavit-Hartenberg parameters. 
        All transformations are computed from the base frame.

        Arguments:
        d (list of double): list of displacements along Z-axis
        theta (list of double): list of rotations around Z-axis
        a (list of double): list of displacements along X-axis
        alpha (list of double): list of rotations around X-axis

        Returns:
        (list of Numpy array): list of transformations along the kinematic chain (from the base frame)
    '''
    #T = [np.eye(4)]
    T = [Tb]  # Base transformation m ,next transformstion is end from first link ot the base , second transformation is end from second link to the base
    # For each set of DH parameters:
    for i in range(len(d)):
        # 1. Compute the DH transformation matrix for the current joint.
        # 2. Compute the resulting accumulated transformation from the base frame.
        T_accumulated = T[-1] @ DH(d[i], theta[i], a[i], alpha[i])
        # 3. Append the computed transformation to T.

        T.append(T_accumulated)

    return T


# Inverse kinematics
def jacobian(T, revolute):
    '''
        Function builds a Jacobian for the end-effector of a robot,
        described by a list of kinematic transformations and a list of joint types.

        Arguments:
        T (list of Numpy array): list of transformations along the kinematic chain of the robot (from the base frame)
        revolute (list of Bool): list of flags specifying if the corresponding joint is a revolute joint

        Returns:
        (Numpy array): end-effector Jacobian
    '''
    # 1. Initialize J and O.
    # 2. For each joint of the robot
    #   a. Extract z and o.
    #   b. Check joint type.
    #   c. Modify corresponding column of J.
    
    # 1. Initialize J and O.
    J = np.zeros((6, len(T)-1 ))  # Initialize the Jacobian matrix with zeros
    On = np.array([T[-1][:3, 3]]).T  # End-effector's origin (position)
    Z = np.array([[0, 0, 1]]).T  # Z-axis of the base frame
    # 2. For each joint of the robot
    for i in range(len(T)-1):
        #   a. Extract z and o.
        # Extract the rotation matrix and origin from the transformation matrix
        Ri = T[i][:3, :3]
        Oi = np.array([T[i][:3, 3]]).T
        
        # Extract the z-axis from the rotation matrix
        Zi = Ri @ Z
        #   b. Check joint type.
        #   c. Modify corresponding column of J.
        if revolute[i]:
            # For revolute joints, use the cross product of z and (O - O_i)
            J[:3, i] = np.cross(Zi.T, (On - Oi).T).T[:, 0]
            J[3:, i] = Zi[:, 0]
        else:
            # For prismatic joints, the linear velocity is along the z-axis, and angular velocity is zero
            J[:3, i] = Zi[:, 0]
    
    return J

# Damped Least-Squares
def DLS(A, damping):
    '''
        Function computes the damped least-squares (DLS) solution to the matrix inverse problem.

        Arguments:
        A (Numpy array): matrix to be inverted
        damping (double): damping factor

        Returns:
        (Numpy array): inversion of the input matrix
    '''
   
    # Create an identity matrix with dimensions matching A @ A.T
    I = np.eye((A @ A.T).shape[0])
     # Compute the DLS
    DLS = A.T @ np.linalg.inv(A @ A.T + damping**2 * I)
    return DLS

def Weighted_DLS(A, damping, W):
    '''
    Function computes the damped least-squares (DLS) solution to the
    matrix inverse problem, incorporating weights for each DOF.
    
    Arguments:
    A (Numpy array): Task Jacobian (m x n matrix).
    damping (float): Damping factor (regularization term).
    W (Numpy array): Diagonal weighting matrix (n x n).
    
    Returns:
    (Numpy array): Weighted DLS solution.
    '''
    # Ensure W is a diagonal matrix
    if len(W.shape) == 1:  # If W is a 1D array, convert to diagonal matrix
        W = np.diag(W)
    
    # Invert W
    W_inv = np.linalg.inv(W)
    
    # Compute Weighted DLS
    identity = np.identity(A.shape[0])  # Ensure identity matches DOF
    term1 = W_inv @ A.T
    term2 = A @ term1 + (damping ** 2) * identity
    return term1 @ np.linalg.inv(term2)


# Extract characteristic points of a robot projected on X-Y plane
def robotPoints2D(T):
    '''
        Function extracts the characteristic points of a kinematic chain on a 2D plane,
        based on the list of transformations that describe it.

        Arguments:
        T (list of Numpy array): list of transformations along the kinematic chain of the robot (from the base frame)
    
        Returns:
        (Numpy array): an array of 2D points
    '''
    P = np.zeros((2,len(T)))
    for i in range(len(T)):
        P[:,i] = T[i][0:2,3]
    return P