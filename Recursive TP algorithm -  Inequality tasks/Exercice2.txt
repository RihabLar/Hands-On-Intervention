from lab4_robotics import *  # Includes numpy import
import matplotlib.pyplot as plt
import matplotlib.animation as anim
import matplotlib.patches as patch

# Robot model
d = np.zeros(3)  # Displacement along Z-axis
theta = np.array([0, 0.6, 0.3])  # Rotation around Z-axis
alpha = np.zeros(3)  # Rotation around X-axis
a = np.array([0.5, 0.75, 0.5])  # Displacement along X-axis
revolute = [True, True, True]  # Flags specifying the type of joints
robot = Manipulator(d, theta, a, alpha, revolute)  # Manipulator object

# Task hierarchy definition
tasks = [
    JointLimits("Position of Joint 1", np.array([-0.5, 0.5]), np.array([0.02, 0.05])),
    Position2D("End-effector position", np.array([1.0, 0.5]).reshape(2, 1))
]

# Simulation params
dt = 1.0 / 60.0

# Drawing preparation
fig = plt.figure()
ax = fig.add_subplot(111, autoscale_on=False, xlim=(-2, 2), ylim=(-2, 2))
ax.set_title('Simulation')
ax.set_aspect('equal')
ax.grid()
ax.set_xlabel('x[m]')
ax.set_ylabel('y[m]')
line, = ax.plot([], [], 'o-', lw=2)  # Robot structure
path, = ax.plot([], [], 'c-', lw=1)  # End-effector path
point, = ax.plot([], [], 'rx')  # Target
# Global variables for storing end-effector path and simulation time
PPx = []
PPy = []
time = []


# Simulation initialization
def init():
    global tasks, i
    line.set_data([], [])
    path.set_data([], [])
    point.set_data([], [])
    tasks[-1].setDesired(np.random.uniform(-1,1,size = (2,1)))   # Random position
    if time:
        i = time[-1]  # Continue time from the last simulation
    else:
        i = 0
    return line, path, point

# Simulation loop
def simulate(t):
    global robot, tasks, PPx, PPy, i
    # Run the Recursive Task-Priority algorithm
    P = np.eye(robot.getDOF())  # Initialize the projector matrix
    dq = np.zeros((robot.getDOF(), 1))  # Initialize joint velocities

    # Loop over tasks, updating each and applying the control law
    for task in tasks:
        task.update(robot)  # Update the task's internal state
        if task.isActive() != 0:
            J = task.getJacobian()
            J_bar = J @ P
            dq_acc = DLS(J_bar, 0.1) @ ((task.getError()) - (J @ dq))
            dq += dq_acc
            P = P - np.linalg.pinv(J_bar) @ J_bar

    # Update the manipulator's state
    robot.update(dq, dt)

    # Update drawing
    PP = robot.drawing()
    line.set_data(PP[0, :], PP[1, :])
    PPx.append(PP[0, -1])
    PPy.append(PP[1, -1])
    path.set_data(PPx, PPy)
    point.set_data(tasks[-1].getDesired()[0], tasks[-1].getDesired()[1])

    time.append(t+i) # Store simulation time

    return line, path, point

# Run simulation
animation = anim.FuncAnimation(fig, simulate, np.arange(0, 10, dt),
                               interval=10, blit=True, init_func=init, repeat=True)
plt.show()

# Evolution of task errors over time
fig_joint = plt.figure()
ax = fig_joint.add_subplot(111, autoscale_on=False, xlim=(0, 60), ylim=(-1, 2))
ax.set_title("Task-Priority Control")
ax.set_xlabel("Time[s]")
ax.set_ylabel("Error / Joint Position")
ax.grid()

# Add horizontal lines for joint limits
ax.axhline(y=tasks[0].safe_set[0], color='r', linestyle='--', label="Lower Limit")
ax.axhline(y=tasks[0].safe_set[1], color='r', linestyle='--', label="Upper Limit")

# Plot task errors over time
plt.plot(time, tasks[0].error, label="q_1 ({})".format(tasks[0].name))  # Joint position
plt.plot(time, tasks[1].error, label="e_2 ({})".format(tasks[-1].name))  # End-effector error
ax.legend()
plt.show()